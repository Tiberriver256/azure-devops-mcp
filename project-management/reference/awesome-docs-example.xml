<file_summary> This section contains a summary of this file. <purpose>
    This file contains a packed representation of the entire repository's contents.
    It is designed to be easily consumable by AI systems for analysis, code review,
    or other automated processes.
</purpose>

<file_format>
  The content is organized as follows:
    1. This summary section
    2. Repository information
    3. Directory structure
    4. Repository files, each consisting of:
    - File path as an attribute
    - Full contents of the file
</file_format>

<usage_guidelines>
  - This file should be treated as read-only. Any changes should be made to the
    original repository files, not this packed version.
    - When processing this file, use the file path to distinguish
    between different files in the repository.
    - Be aware that this file may contain sensitive information. Handle it with
    the same level of security as you would the original repository.
</usage_guidelines>

<notes>
  - Some files may have been excluded based on .gitignore rules and Repomix's configuration
    - Binary files are not included in this packed representation. Please refer to the Repository
  Structure section for a complete list of file paths, including binary files
    - Only files matching these patterns are included: README.md, docs/**
    - Files matching patterns in .gitignore are excluded
    - Files matching default ignore patterns are excluded
    - Empty lines have been removed from all files
    - Security check has been disabled - content may contain sensitive information
</notes>

<additional_info>

  </additional_info>

</file_summary>

<directory_structure>
  docs/
  additional-resources.md
  api-layer.md
  application-overview.md
  components-and-styling.md
  deployment.md
  error-handling.md
  performance.md
  project-standards.md
  project-structure.md
  security.md
  state-management.md
  testing.md
  README.md
</directory_structure>

<files> This section contains the contents of the repository's files. <file
    path="docs/additional-resources.md">
    # 📚 Additional Resources

    ## React

    - [Official Documentation](https://react.dev/)
    - [Tao Of React](https://alexkondov.com/tao-of-react/)
    - [React Handbook](https://reacthandbook.dev/)
    - [React Philosophies](https://github.com/mithi/react-philosophies)
    - [React Patterns](https://reactpatterns.com/)
    - [React Typescript Cheatsheet](https://react-typescript-cheatsheet.netlify.app/)

    ## JavaScript

    - [You Dont Know JS](https://github.com/getify/You-Dont-Know-JS)
    - [JavaScript Info](https://javascript.info/)
    - [33 Concepts Every JavaScript Developer Should
  Know](https://github.com/leonardomso/33-js-concepts#8-iife-modules-and-namespaces)
    - [JavaScript to Know for React](https://kentcdodds.com/blog/javascript-to-know-for-react)

    ## Best Practices

    - [patterns.dev](https://www.patterns.dev/)
    - [Naming Cheatsheet](https://github.com/kettanaito/naming-cheatsheet)
    - [Clean Code Javascript](https://github.com/ryanmcdermott/clean-code-javascript)
</file>

<file
    path="docs/api-layer.md">
    # 📡 API Layer

    ### Use a Single Instance of the API Client

    When your application interacts with either RESTful or GraphQL APIs, it is beneficial to use a
  single instance of the API client that has been pre-configured and can be reused throughout the
  application. For example, you can create a single API client instance using the native fetch API
  or libraries such as [axios](https://github.com/axios/axios),
  [graphql-request](https://github.com/prisma-labs/graphql-request), or
  [apollo-client](https://www.apollographql.com/docs/react/) with predefined configuration settings.
  [API Client Example Code](../apps/react-vite/src/lib/api-client.ts)

    ### Define and Export Request Declarations

    Rather than declaring API requests on the fly, it is recommended to define and export them
  separately.

    Declaring API requests in a structured manner can help maintain a clean and organized codebase
  as everything is colocated.
    Every API request declaration should consist of:

    - Types and validation schemas for the request and response data
    - A fetcher function that calls an endpoint, using the API client instance
    - A hook that consumes the fetcher function that is built on top of libraries such as
  [react-query](https://tanstack.com/query), [swr](https://swr.vercel.app/),
  [apollo-client](https://www.apollographql.com/docs/react/),
  [urql](https://formidable.com/open-source/urql/), etc. to manage the data fetching and caching
  logic.

    This approach simplifies the tracking of defined endpoints available in the application.
  Additionally, typing the responses and inferring them further down the application enhances
  application type safety.

    [API Request Declarations - Query - Example
  Code](../apps/react-vite/src/features/discussions/api/get-discussions.ts)
    [API Request Declarations - Mutation - Example
  Code](../apps/react-vite/src/features/discussions/api/create-discussion.ts)
</file>

<file
    path="docs/application-overview.md">
    # 💻 Application Overview

    The application is relatively simple. Users can create teams where other users can join, and
  they start discussions on different topics between each other.

    A team is created during the registration if the user didn't choose to join an existing team and
  the user becomes the admin of it.

    [Demo](https://bulletproof-react-app.netlify.app)

    ## Data model

    The application contains the following models:

    - User - can have one of these roles:

    - `ADMIN` can:
    - create/edit/delete discussions
    - create/delete all comments
    - delete users
    - edit own profile
    - `USER` - can:
    - edit own profile
    - create/delete own comments

    - Team: represents a team that has 1 admin and many users that can participate in discussions
  between each other.

    - Discussion: represents discussions created by team members.

    - Comment: represents all the messages in a discussion.

    ## Get Started

    To get started, check the README.md file in the application you want to run.

    - [React Vite](../apps/react-vite/README.md)
    - [Next.js App Router](../apps/nextjs-app/README.md)
    - [Next.js Pages](../apps/nextjs-pages/README.md)
</file>

<file
    path="docs/components-and-styling.md"> # 🧱 Components And Styling ## Components Best Practices
  #### Colocate things as close as possible to where it's being used Keep components, functions,
  styles, state, etc. as close as possible to where they are being used. This will not only make
  your codebase more readable and easier to understand but it will also improve your application
  performance since it will reduce redundant re-renders on state updates. #### Avoid large
  components with nested rendering functions Do not add multiple rendering functions inside your
  application, this gets out of control pretty quickly. What you should do instead is if there is a
  piece of UI that can be considered as a unit, is to extract it in a separate component.
  ```javascript // this is very difficult to maintain as soon as the component starts growing
  function Component() { function renderItems() { return <ul>...</ul>; } return <div>{renderItems()}</div>;
  } // extract it in a separate component function Items() { return <ul>...</ul>; } function
  Component() { return ( <div>
      <Items />
    </div> ); } ``` #### Stay consistent Keep your code style consistent. For
  example, if you name your components using pascal case, do it everywhere. Most of code consistency
  is achieved by using linters and code formatters, so make sure you have them set up in your
  project. #### Limit the number of props a component is accepting as input If your component is
  accepting too many props you might consider splitting it into multiple components or use the
  composition technique via children or slots. [Composition Example
  Code](../apps/react-vite/src/components/ui/dialog/confirmation-dialog/confirmation-dialog.tsx)
  #### Abstract shared components into a component library For larger projects, it is a good idea to
  build abstractions around all the shared components. It makes the application more consistent and
  easier to maintain. Identify repetitions before creating the components to avoid wrong
  abstractions. [Component Library Example
  Code](../apps/react-vite/src/components/ui/button/button.tsx) It is a good idea to wrap 3rd party
  components as well in order to adapt them to the application's needs. It might be easier to make
  the underlying changes in the future without affecting the application's functionality. [3rd Party
  Component Example Code](../apps/react-vite/src/components/ui/link/link.tsx) ## Component libraries
  Every project requires some UI components such as modals, tabs, sidebars, menus, etc. Instead of
  building those from scratch, you might want to use some of the existing, battle-tested component
  libraries. #### Fully featured component libraries: These component libraries come with their
  components fully styled. - [Chakra UI](https://chakra-ui.com/) - great library with great
  developer experience, allows very fast prototyping with decent design defaults. Plenty of
  components that are very customizable and flexible with accessibility already configured out of
  the box. - [AntD](https://ant.design/) - another great component library that has a lot of
  different components. Best suitable for creating admin dashboards. However, it might be a bit
  difficult to change the styles in order to adapt them to a custom design. -
  [MUI](https://mui.com/material-ui/) - the most popular component library for React. Has a lot of
  different components. Can be used as a styled solution by implementing Material Design or as
  unstyled headless component library. - [Mantine](https://mantine.dev/) - a modern react component
  library with a lot of components and hooks. It is very customizable and has a lot of features out
  of the box. #### Headless component libraries: These component libraries come with their
  components unstyled. If you have a specific design system to implement, it might be easier and
  better solution to go with headless components that come unstyled than to adapt a fully featured
  component library such as Material UI to your needs. Some good options are: - [Radix
  UI](https://www.radix-ui.com/) - [Headless UI](https://headlessui.dev/) -
  [react-aria](https://react-spectrum.adobe.com/react-aria/) - [Ark UI](https://ark-ui.com/) -
  [Reakit](https://reakit.io/) ## Styling Solutions There are multiple ways to style a react
  application. Some good options are: - [tailwind](https://tailwindcss.com/) -
  [vanilla-extract](https://github.com/seek-oss/vanilla-extract) - [Panda
  CSS](https://panda-css.com/) - [CSS modules](https://github.com/css-modules/css-modules) -
  [styled-components](https://styled-components.com/) -
  [emotion](https://emotion.sh/docs/introduction) NOTE: Keep React Server Components in mind as they
  require zero runtime styling solution. With the rise of headless component libraries, there is
  another tier of component libraries where predefined components are provided with styling
  solutions included, but instead of being installed as a package, they are provided as code which
  can be customized and styled as needed. - [ShadCN UI](https://ui.shadcn.com/) - [Park
  UI](https://park-ui.com/) ## Storybook [Storybook](https://storybook.js.org/) is a great tool for
  developing and testing components in isolation. Think of it as a catalogue of all the components
  your application is using. Very useful for developing and discoverability of components.
  [Storybook Story Example Code](../apps/react-vite/src/components/ui/button/button.stories.tsx) </file>

<file
    path="docs/deployment.md">
    # 🌐 Deployment

    Deploy and serve your applications and assets over a CDN for best delivery and performance. Good
  options for that are:

    - [Vercel](https://vercel.com/)
    - [Netlify](https://www.netlify.com/)
    - [AWS](https://aws.amazon.com/cloudfront/)
    - [CloudFlare](https://www.cloudflare.com/en-gb/cdn/)
</file>

<file
    path="docs/error-handling.md">
    # ⚠️ Error Handling

    ### API Errors

    Implement an interceptor to manage errors effectively. This interceptor can be utilized to
  trigger notification toasts informing users of errors, log out unauthorized users, or send
  requests to refresh tokens to maintain secure and seamless application operation.

    [API Errors Notification Example Code](../apps/react-vite/src/lib/api-client.ts)

    ### In App Errors

    Utilize error boundaries in React to handle errors within specific parts of your application.
  Instead of having only one error boundary for the entire app, consider placing multiple error
  boundaries in different areas. This way, if an error occurs, it can be contained and managed
  locally without disrupting the entire application's functionality, ensuring a smoother user
  experience.

    [Error Boundary Example Code](../apps/react-vite/src/app/routes/app/discussions/discussion.tsx)
  ### Error Tracking

    You should track any errors that occur in production. Although it's possible to implement your
  own solution, it is a better idea to use tools like [Sentry](https://sentry.io/). It will report
  any issue that breaks the app. You will also be able to see on which platform, browser, etc. did
  it occur. Make sure to upload source maps to sentry to see where in your source code did the error
  happen.
</file>

<file
    path="docs/performance.md"> # 🚄 Performance ### Code Splitting Code splitting involves
  splitting production JavaScript into smaller files to optimize application loading times. This
  technique enables the application to be downloaded in parts, fetching only the necessary code when
  required. Ideally, code splitting should be implemented at the routes level, ensuring that only
  essential code is loaded initially, with additional parts fetched lazily as needed. It's important
  to avoid excessive code splitting, as this can lead to a performance decline due to the increased
  number of requests required to fetch all the code chunks. Strategic code splitting, focusing on
  critical parts of the application, helps balance performance optimization with efficient resource
  loading. [Code Splitting Example Code](../apps/react-vite/src/app/router.tsx) ### Component and
  state optimizations - Do not put everything in a single state. That might trigger unnecessary
  re-renders. Instead split the global state into multiple states according to where they are being
  used. - Keep the state as close as possible to where it is being used. This will prevent
  re-rendering components that do not depend on the updated state. - If you have a piece of state
  that is initialized by an expensive computation, use the state initializer function instead of
  executing it directly because the expensive function will be run only once as it is supposed to.
  e.g: ```javascript // instead of this which would be executed on every re-render: const [state,
  setState] = React.useState(myExpensiveFn()); // prefer this which is executed only once: const
  [state, setState] = React.useState(() => myExpensiveFn()); ``` - If you develop an application
  that requires a state to track many elements at once, you might consider state management
  libraries with atomic updates such as [jotai](https://jotai.pmnd.rs/). - Use React Context wisely.
  React Context is good for low-velocity data like themes, user data, small local state etc. While
  dealing with medium-velocity/high-velocity data, you may consider using the
  [use-context-selector](https://github.com/dai-shi/use-context-selector) library that supports
  selectors (selectors are already built-in in most popular state management libraries like
  [zustand](https://docs.pmnd.rs/zustand/getting-started/introduction) or
  [jotai](https://jotai.org/)). Important to remember, context is often used as the "golden tool"
  for props drilling, whereas in many scenarios you may satisfy your needs by [lifting the state
  up](https://react.dev/learn/sharing-state-between-components#lifting-state-up-by-example) or [a
  proper composition of
  components](https://react.dev/learn/passing-data-deeply-with-context#before-you-use-context). Do
  not rush with context and global state. - If your application is expected to have frequent updates
  that might affect performance, consider switching from runtime styling solutions such as
  [emotion](https://emotion.sh/docs/introduction),
  [styled-components](https://styled-components.com/) that generate styles during runtime) to zero
  runtime styling solutions ([tailwind](https://tailwindcss.com/),
  [vanilla-extract](https://github.com/seek-oss/vanilla-extract), [CSS
  modules](https://github.com/css-modules/css-modules) which generate styles during build time). ###
  Children as the most basic optimization - The `children` prop is the most basic and easiest way to
  optimize your components. When applied properly, it eliminates a lot of unnecessary rerenders. The
  JSX, passed in the form of `children` prop, represents an isolated VDOM structure that does not
  need (and cannot) be re-rendered by its parent. Example below: ```javascript // Not optimized
  example const App = () => <Counter />; const Counter = () => { const [count, setCount] =
  useState(0); return ( <div>
      <button onClick= {()=> setCount((count) => count + 1)}>
        count is {count}
      </button>
      <PureComponent /> //
  will rerender whenever "count" updates </div> ); }; const PureComponent = () => <p>Pure Component</p>;
  // Optimized example const App = () => ( <Counter>
      <PureComponent />
    </Counter> ); const Counter = ({ children }) => { const [count, setCount]
  = useState(0); return ( <div>
      <button onClick= {()=> setCount((count) => count + 1)}>
        count is {count}
      </button> {children} // won't
  rerender whenever "count" updates </div> ); }; const PureComponent = () => <p>Pure Component</p>;
  ``` ### Image optimizations Consider lazy loading images that are not in the viewport. Use modern
  image formats such as WEBP for faster image loading. Use `srcset` to load the most optimal image
  for the clients screen size. ### Web vitals Since Google started taking web vitals in account when
  indexing websites, you should keep an eye on web vitals scores from
  [Lighthouse](https://web.dev/measure/) and [Pagespeed Insights](https://pagespeed.web.dev/). ###
  Data prefetching It is possible to prefetch data before the user navigates to a page. This can be
  done by using the `queryClient.prefetchQuery` method from the `@tanstack/react-query` library.
  This method allows you to prefetch data for a specific query. This can be useful when you know
  that the user will navigate to a specific page and you want to prefetch the data before the user
  navigates to the page. This can help to improve the performance of the application by reducing the
  time it takes to load the data when the user navigates to the page. [Data Prefetching Example
  Code](../apps/react-vite/src/features/discussions/components/discussions-list.tsx) </file>

<file
    path="docs/project-standards.md">
    # ⚙️ Project Standards

    Enforcing project standards is crucial for maintaining code quality, consistency, and
  scalability in a React application. By establishing and adhering to a set of best practices,
  developers can ensure that the codebase remains clean, organized, and easy to maintain.

    #### ESLint

    ESLint serves as a valuable linting tool for JavaScript, helping developers in maintaining code
  quality and adhering to coding standards. By configuring rules in the `.eslintrc.js` file, ESLint
  helps identify and prevent common errors, ensuring code correctness and promoting consistency
  throughout the codebase. This approach not only helps in catching mistakes early but also enforces
  uniformity in coding practices, thereby enhancing the overall quality and readability of the code.
  [ESLint Configuration Example Code](../apps/react-vite/.eslintrc.cjs)

    #### Prettier

    Prettier is a useful tool for maintaining consistent code formatting in your project. By
  enabling the "format on save" feature in your IDE, code is automatically formatted according to
  the rules set in the `.prettierrc` configuration file. This practice ensures a uniform code style
  across your codebase and provides helpful feedback on code issues. If the auto-formatting fails,
  it signals potential syntax error. Furthermore, Prettier can be integrated with ESLint to handle
  code formatting tasks alongside enforcing coding standards effectively throughout the development
  process.

    [Prettier Configuration Example Code](../apps/react-vite/.prettierrc)

    #### TypeScript

    ESLint is effective for detecting language-related bugs in JavaScript. However, due to
  JavaScript's dynamic nature, ESLint may not catch all runtime data issues, especially in complex
  projects. To address this, TypeScript is recommended. TypeScript is valuable for identifying
  issues during large refactoring processes that may go unnoticed. When refactoring, prioritize
  updating type declarations first, then resolving TypeScript errors throughout the project. It's
  important to note that while TypeScript enhances development confidence by performing type
  checking at build time, it does not prevent runtime failures. Here is a [great resource on using
  TypeScript with React](https://react-typescript-cheatsheet.netlify.app/).

    #### Husky

    Husky is a valuable tool for implementing and executing git hooks in your workflow. By utilizing
  Husky to run code validations before each commit, you can ensure that your code maintains high
  standards and that no faulty commits are pushed to the repository. Husky enables you to perform
  various tasks such as linting, code formatting, and type checking before allowing code pushes. You
  can check how to configure it [here](https://typicode.github.io/husky/#/?id=usage).

    #### Absolute imports

    Absolute imports should always be configured and used because it makes it easier to move files
  around and avoid messy import paths such as `../../../component`. Wherever you move the file, all
  the imports will remain intact. Here is how to configure it:

    For JavaScript (`jsconfig.json`) projects:

    ```json
    "compilerOptions": {
    "baseUrl": ".",
    "paths": {
    "@/*": ["./src/*"]
    }
    }
    ```

    For TypeScript (`tsconfig.json`) projects:

    ```json
    "compilerOptions": {
    "baseUrl": ".",
    "paths": {
    "@/*": ["./src/*"]
    }
    }
    ```

    It is also possible to define multiple paths for various folders(such as `@components`,
  `@hooks`, etc.), but using `@/*` works very well because it is short enough so there is no need to
  configure multiple paths and it differs from other dependency modules so there is no confusion in
  what comes from `node_modules` and what is our source folder. That means that anything in the
  `src` folder can be accessed via `@`, e.g some file that lives in `src/components/my-component`
  can be accessed using `@/components/my-component` instead of `../../../components/my-component`.
  #### File naming conventions

    We can also enforce the file naming conventions and folder naming conventions in the project.
  For example, you can enforce that all files should be named in `kebab-case`. This can help you to
  keep your codebase consistent and easier to navigate.

    To enforce this, you can use ESLint:

    ```js
    'check-file/filename-naming-convention': [
    'error',
    {
    '**/*.{ts,tsx}': 'KEBAB_CASE',
    },
    {
    // ignore the middle extensions of the filename to support filename like bable.config.js or
  smoke.spec.ts
    ignoreMiddleExtensions: true,
    },
    ],
    'check-file/folder-naming-convention': [
    'error',
    {
    // all folders within src (except __tests__)should be named in kebab-case
    'src/**/!(__tests__)': 'KEBAB_CASE',
    },
    ],
    ```
</file>

<file
    path="docs/project-structure.md">
    # 🗄️ Project Structure

    Most of the code lives in the `src` folder and looks something like this:

    ```sh
    src
    |
    +-- app # application layer containing:
    | | # this folder might differ based on the meta framework used
    | +-- routes # application routes / can also be pages
    | +-- app.tsx # main application component
    | +-- provider.tsx # application provider that wraps the entire application with different
  global providers - this might also differ based on meta framework used
    | +-- router.tsx # application router configuration
    +-- assets # assets folder can contain all the static files such as images, fonts, etc.
    |
    +-- components # shared components used across the entire application
    |
    +-- config # global configurations, exported env variables etc.
    |
    +-- features # feature based modules
    |
    +-- hooks # shared hooks used across the entire application
    |
    +-- lib # reusable libraries preconfigured for the application
    |
    +-- stores # global state stores
    |
    +-- testing # test utilities and mocks
    |
    +-- types # shared types used across the application
    |
    +-- utils # shared utility functions
    ```

    For easy scalability and maintenance, organize most of the code within the features folder. Each
  feature folder should contain code specific to that feature, keeping things neatly separated. This
  approach helps prevent mixing feature-related code with shared components, making it simpler to
  manage and maintain the codebase compared to having many files in a flat folder structure. By
  adopting this method, you can enhance collaboration, readability, and scalability in the
  application's architecture.

    A feature could have the following structure:

    ```sh
    src/features/awesome-feature
    |
    +-- api # exported API request declarations and api hooks related to a specific feature
    |
    +-- assets # assets folder can contain all the static files for a specific feature
    |
    +-- components # components scoped to a specific feature
    |
    +-- hooks # hooks scoped to a specific feature
    |
    +-- stores # state stores for a specific feature
    |
    +-- types # typescript types used within the feature
    |
    +-- utils # utility functions for a specific feature
    ```

    NOTE: You don't need all of these folders for every feature. Only include the ones that are
  necessary for the feature.

    In some cases it might be more practical to keep all API calls outside of the features folders
  in a dedicated `api` folder where all API calls are defined. This can be useful if you have a lot
  of shared API calls between features.

    In the past, it was recommended to use barrel files to export all the files from a feature.
  However, it can cause issues for Vite to do tree shaking and can lead to performance issues.
  Therefore, it is recommended to import the files directly.

    It might not be a good idea to import across the features. Instead, compose different features
  at the application level. This way, you can ensure that each feature is independent which makes
  the codebase less convoluted.

    To forbid cross-feature imports, you can use ESLint:

    ```js
    'import/no-restricted-paths': [
    'error',
    {
    zones: [
    // disables cross-feature imports:
    // eg. src/features/discussions should not import from src/features/comments, etc.
    {
    target: './src/features/auth',
    from: './src/features',
    except: ['./auth'],
    },
    {
    target: './src/features/comments',
    from: './src/features',
    except: ['./comments'],
    },
    {
    target: './src/features/discussions',
    from: './src/features',
    except: ['./discussions'],
    },
    {
    target: './src/features/teams',
    from: './src/features',
    except: ['./teams'],
    },
    {
    target: './src/features/users',
    from: './src/features',
    except: ['./users'],
    },

    // More restrictions...
    ],
    },
    ],
    ```

    You might also want to enforce unidirectional codebase architecture. This means that the code
  should flow in one direction, from shared parts of the code to the application (shared -> features
  -> app). This is a good practice to follow as it makes the codebase more predictable and easier to
  understand.

    ![Unidirectional Codebase](./assets/unidirectional-codebase.png)

    As you can see, the shared parts can be used by any part of the codebase, but the features can
  only import from shared parts and the app can import from features and shared parts.

    To enforce this, you can use ESLint:

    ```js
    'import/no-restricted-paths': [
    'error',
    {
    zones: [
    // Previous restrictions...

    // enforce unidirectional codebase:
    // e.g. src/app can import from src/features but not the other way around
    {
    target: './src/features',
    from: './src/app',
    },

    // e.g src/features and src/app can import from these shared modules but not the other way
  around
    {
    target: [
    './src/components',
    './src/hooks',
    './src/lib',
    './src/types',
    './src/utils',
    ],
    from: ['./src/features', './src/app'],
    },
    ],
    },
    ],
    ```

    By following these practices, you can ensure that your codebase is well-organized, scalable, and
  maintainable. This will help you and your team to work more efficiently and effectively on the
  project.
    This approach can also make it easier to apply similar architecture to apps built with Next.js,
  Remix or React Native.
</file>

<file
    path="docs/security.md">
    # 🔐 Security

    ## Auth

    NOTE: While managing authentication on the client side is crucial, it is equally vital to
  implement robust security measures on the server to protect resources. Client-side authentication
  enhances user experience and complements server-side security measures.

    Protecting resources comprises two key components:

    ### Authentication

    Authentication is the process of verifying the identity of a user. In single-page applications
  (SPAs), the prevalent method of authenticating users is through JSON Web Tokens
  ([JWT](https://jwt.io/)). When a user logs in or registers, they receive a token that is stored
  within the application. Subsequently, for each authenticated request, the token is sent in the
  header or via a cookie along with the request to validate the user's identity and access
  permissions.

    The most secure practice is to store the token in the application state. However, it's important
  to note that if the user refreshes the application, the token will be reset. That can lead to the
  loss of the user's authentication status.

    That is why tokens need to be stored in a cookie or `localStorage/sessionStorage`.

    #### `localStorage` vs cookie for storing tokens

    Storing authentication tokens in localStorage can pose a security risk, especially in the
  context of Cross-Site Scripting ([XSS](https://owasp.org/www-community/attacks/xss/))
  vulnerabilities, potentially leading to token theft by malicious actors.

    Opting to store tokens in cookies, configured with the `HttpOnly` attribute, can enhance
  security as they are inaccessible to client-side JavaScript. In our sample app, we utilize
  js-cookie for cookie management, assuming the real API would enforce the HttpOnly attribute for
  enhanced security, and the application does not have access to the cookie from the client side.

    In addition to securely storing tokens, it's crucial to protect the entire application from
  Cross-Site Scripting (XSS) attacks. One key strategy is to sanitize all user inputs before
  displaying them in the application. By carefully sanitizing inputs, you can reduce the risk of XSS
  vulnerabilities, making the application more resilient to malicious attacks and enhancing overall
  security for users.

    [HTML Sanitization Example Code](../apps/react-vite/src/components/ui/md-preview/md-preview.tsx)
  For a full list of security risks, check
  [OWASP](https://owasp.org/www-project-top-10-client-side-security-risks/).

    #### Handling user data

    User info should be considered a global piece of state which should be available from anywhere
  in the application.
    If you are already using `react-query`, you can use
  [react-query-auth](https://github.com/alan2207/react-query-auth) library for handling user state
  which will handle all the things for you after you provide it some configuration. Otherwise, you
  can use react context + hooks, or some 3rd party state management library.

    User information should be treated as a central piece of data accessible throughout the
  application. If you are already using `react-query`, consider using it for storing user data as
  well. Alternatively, you can leverage React context with hooks or opt for a third-party state
  management library to efficiently manage user state across your application.

    [Auth Configuration Example Code](../apps/react-vite/src/lib/auth.tsx)

    The application will assume the user is authenticated if a user object is present.

    ### Authorization

    Authorization is the process of verifying whether a user has permission to access a specific
  resource within the application.

    #### RBAC (Role based access control)

    [Authorization Configuration Example Code](../apps/react-vite/src/lib/authorization.tsx)

    In a role-based authorization model, access to resources is determined by defining specific
  roles and associating them with permissions. For example, roles such as `USER` and `ADMIN` can be
  assigned different levels of access rights within the application. Users are then granted access
  based on their roles; for instance, restricting certain functionalities to regular users while
  permitting administrators to access all features and functionalities.

    [RBAC Example
  Code](../apps/react-vite/src/features/discussions/components/create-discussion.tsx)

    #### PBAC (Permission based access control)

    While Role-Based Access Control (RBAC) provides a structured methodology for authorization,
  there are instances where a more granular approach is necessary. Precision-Based Access Control
  (PBAC) offers a more flexible solution, particularly in scenarios where access permissions need to
  be finely tuned based on specific criteria, such as allowing only the owner of a resource to
  perform certain operations. For example, in the case of a user's comment, PBAC ensures that only
  the author of the comment has the privilege to delete it, adding a layer of precision and
  customization to access control mechanisms.

    For RBAC protection, you can use the `RBAC` component by passing allowed roles to it. On the
  other hand, if you need more strict protection, you can pass policies check to it.

    [PBAC Example Code](../apps/react-vite/src/features/comments/components/comments-list.tsx)
</file>

<file
    path="docs/state-management.md">
    # 🗃️ State Management

    Managing state effectively is crucial for optimizing your application's performance. Instead of
  storing all state information in a single centralized repository, consider dividing it into
  various categories based on their usage. By categorizing your state, you can streamline your state
  management process and enhance your application's overall efficiency.

    ## Component State

    Component state is specific to individual components and should not be shared globally. It can
  be passed down to child components as props when necessary. Typically, you should begin by
  defining state within the component itself and consider elevating it to a higher level if it's
  required elsewhere in the application. When managing component state, you can use the following
  React hooks:

    - [useState](https://react.dev/reference/react/useState) - for simpler states that are
  independent
    - [useReducer](https://react.dev/reference/react/useReducer) - for more complex states where on
  a single action you want to update several pieces of state

    [Component State Example Code](../apps/react-vite/src/components/layouts/dashboard-layout.tsx)

    ## Application State

    Application state manages global parts of an application, such as controlling global modals,
  notifications, and toggling color modes. To ensure optimal performance and ease of maintenance, it
  is advisable to localize the state as closely as possible to the components that require it. Avoid
  unnecessarily globalizing all state variables from the outset to maintain a structured and
  efficient state management architecture.

    Good Application State Solutions:

    - [context](https://react.dev/learn/passing-data-deeply-with-context) +
  [hooks](https://react.dev/reference/react-dom/hooks)
    - [redux](https://redux.js.org/) + [redux toolkit](https://redux-toolkit.js.org/)
    - [mobx](https://mobx.js.org)
    - [zustand](https://github.com/pmndrs/zustand)
    - [jotai](https://github.com/pmndrs/jotai)
    - [xstate](https://xstate.js.org/)

    [Global State Example
  Code](../apps/react-vite/src/components/ui/notifications/notifications-store.ts)

    ## Server Cache State

    The Server Cache State refers to the data retrieved from the server that is stored locally on
  the client-side for future use. While it is feasible to cache remote data within a state
  management store like Redux, there exist more optimal solutions to this practice. It is essential
  to consider more efficient caching mechanisms to enhance performance and optimize data retrieval
  processes.

    Good Server Cache Libraries:

    - [react-query](https://tanstack.com/query) - REST + GraphQL
    - [swr](https://swr.vercel.app/) - REST + GraphQL
    - [apollo client](https://www.apollographql.com/) - GraphQL
    - [urql](https://formidable.com/open-source/urql/) - GraphQl
    - [RTK](https://redux-toolkit.js.org/rtk-query)

    [Server Cache State Example
  Code](../apps/react-vite/src/features/discussions/api/get-discussions.ts)

    ## Form State

    Forms are a crucial part of any application, and managing form state effectively is essential
  for a seamless user experience. When handling form state, consider using libraries like Formik,
  React Hook Form, or Final Form to streamline the process. These libraries provide built-in
  validation, error handling, and form submission functionalities, making it easier to manage form
  state within your application.

    Forms in React can be [controlled and
  uncontrolled](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components).
  Depending on the application needs, they might be pretty complex with many different fields that
  require validation.

    Although it is possible to build any form using only React primitives, there are some good
  solutions out there that help with handling forms such as:

    - [React Hook Form](https://react-hook-form.com/)
    - [Formik](https://formik.org/)
    - [React Final Form](https://github.com/final-form/react-final-form)

    Create abstracted `Form` component and all the input field components that wrap the library
  functionality and are adapted to the application needs.

    [Form Example Code](../apps/react-vite/src/components/ui/form/form.tsx)

    [Input Field Example Code](../apps/react-vite/src/components/ui/form/input.tsx)

    You can also integrate validation libraries with the mentioned solutions to validate inputs on
  the client. Some good options are:

    - [zod](https://github.com/colinhacks/zod)
    - [yup](https://github.com/jquense/yup)

    [Validation Example Code](../apps/react-vite/src/features/auth/components/register-form.tsx)

    ## URL State

    URL state refers to the data stored and manipulated within the address bar of the browser. This
  state is commonly managed through URL parameters (e.g., /app/${dynamicParam}) or query parameters
  (e.g., /app?dynamicParam=1). By incorporating routing solutions like react-router-dom, you can
  effectively access and control the URL state, enabling dynamic manipulation of application
  parameters directly from the browser's address bar.

    [URL State Example
  Code](../apps/react-vite/src/features/discussions/components/discussion-view.tsx)
</file>

<file
    path="docs/testing.md">
    # 🧪 Testing

    As highlighted in this [tweet](https://twitter.com/rauchg/status/807626710350839808), the
  efficacy of testing lies in the comprehensive coverage provided by integration and end-to-end
  (e2e) tests. While unit tests serve a purpose in isolating and validating individual components,
  the true value and confidence in application functionality stem from robust integration and e2e
  testing strategies.

    ## Types of tests:

    ### Unit Tests

    Unit tests are the smallest tests you can write. They test individual parts of your application
  in isolation. They are useful for testing shared components and functions that are used throughout
  the entire application. They are also useful for testing complex logic in a single component. They
  are fast to run and easy to write.

    [Unit Test Example
  Code](../apps/react-vite/src/components/ui/dialog/confirmation-dialog/__tests__/confirmation-dialog.test.tsx)
  ### Integration Tests

    Integration testing checks how different parts of your application work together. It's crucial
  to focus on integration tests for most of your testing, as they provide significant benefits and
  boost confidence in your application's reliability. While unit tests are helpful for individual
  parts, passing them doesn't guarantee your app will function correctly if the connections between
  parts are flawed. Testing various features with integration tests is vital to ensure that your
  application works smoothly and consistently.

    [Integration Test Example
  Code](../apps/react-vite/src/app/routes/app/discussions/__tests__/discussion.test.tsx)

    ### E2E

    End-to-End Testing is a method that evaluates an application as a whole. These tests involve
  automating the complete application, including both the frontend and backend, to confirm that the
  entire system functions correctly. End-to-End tests simulate how a user would interact with the
  application.

    [E2E Example Code](../apps/react-vite/e2e/tests/smoke.spec.ts)

    ## Recommended Tooling:

    #### [Vitest](https://vitest.dev)

    Vitest is a powerful testing framework with features similar to Jest, but it's more up-to-date
  and works well with modern tools. It's highly customizable and flexible, making it a popular
  option for testing JavaScript code.

    #### [Testing Library](https://testing-library.com/)

    Testing library is a set of libraries and tools that makes testing easier than ever before. Its
  philosophy is to test your app in a way it is being used by a real world user instead of testing
  implementation details. For example, don't test what is the current state value in a component,
  but test what that component renders on the screen for its user. If you refactor your app to use a
  different state management solution for example, the tests should still be relevant as the actual
  component output to the user shouldn't change.

    #### [Playwright](https://playwright.dev)

    Playwright is a tool for running e2e tests in an automated way.
    You define all the commands a real world user would execute when using the app and then start
  the test. It can be started in 2 modes:

    - Browser mode - it will open a dedicated browser and run your application from start to finish.
  You get a nice set of tools to visualize and inspect your application on each step. Since this is
  a more expensive option, you want to run it only locally when developing the application.
    - Headless mode - it will start a headless browser and run your application. Very useful for
  integrating with CI/CD to run it on every deploy.

    #### [MSW](https://mswjs.io)

    For prototyping the API use msw, which is a great tool for quickly creating frontends without
  worrying about servers. It is not an actual backend, but a mocked server inside a service worker
  that intercepts all HTTP requests and returns desired responses based on the handlers you define.
  This is especially useful if you only have access to the frontend and are blocked by some not
  implemented features on the backend. This way, you will not be forced to wait for the feature to
  be completed or hardcode response data in the code, but use actual HTTP calls to build frontend
  features.

    It can be used for designing API endpoints. The business logic of the mocked API can be created
  in its handlers.

    [API Handlers Example Code](../apps/react-vite/src/testing/mocks/handlers/auth.ts)

    [Data Models Example Code](../apps/react-vite/src/testing/mocks/db.ts)

    Having a fully functional mocked API server is also handy when it comes to testing, you don't
  have to mock fetch, but make requests to the mocked server instead with the data your application
  would expect.
</file>

<file
    path="README.md">
    # Bulletproof React 🛡️ ⚛️

    [![MIT
  License](https://img.shields.io/github/license/alan2207/bulletproof-react)](https://github.com/alan2207/bulletproof-react/blob/master/LICENSE)
  [![Next.js App
  CI](https://github.com/alan2207/bulletproof-react/actions/workflows/nextjs-app-ci.yml/badge.svg)](https://github.com/alan2207/bulletproof-react/actions/workflows/nextjs-app-ci.yml)
  [![Next.js Pages
  CI](https://github.com/alan2207/bulletproof-react/actions/workflows/nextjs-pages-ci.yml/badge.svg)](https://github.com/alan2207/bulletproof-react/actions/workflows/nextjs-pages-ci.yml)
  [![React Vite
  CI](https://github.com/alan2207/bulletproof-react/actions/workflows/react-vite-ci.yml/badge.svg)](https://github.com/alan2207/bulletproof-react/actions/workflows/react-vite-ci.yml)
  A simple, scalable, and powerful architecture for building production ready React applications.

    ## Introduction

    React is an excellent tool for building front-end applications. It has a diverse ecosystem with
  hundreds of great libraries for literally anything you might need. However, being forced to make
  so many choices can be overwhelming. It is also very flexible, you can write React applications in
  any way you like, but that flexibility comes with a cost. Since there is no pre-defined
  architecture that developers can follow, it often leads to a messy, inconsistent, and
  over-complicated codebase.

    This repo attempts to present a way of creating React applications using some of the best tools
  in the ecosystem with a good project structure that scales very well. Based on my experience
  working with a lot of different codebases, this architecture turns out to be the most effective.
  The goal here is to serve as a collection of resources and best practices when developing React
  applications. It is supposed to showcase solving most of the real-world problems of an application
  in a practical way and help developers write better applications.

    Feel free to explore the sample app codebase to get the most value out of the repo.

    ## What makes a React application "bulletproof"?

    This repo doesn't aim to be a silver bullet for all React applications as there are many
  different use cases, but it tries to provide a solid foundation for building applications based on
  the following principles:

    - Easy to get started with
    - Simple to understand and maintain
    - Uses the right tools for the job
    - Clean boundaries between different parts of the application
    - Everyone on the team is on the same page when it comes to how things are done
    - Secure
    - Performant
    - Scalable in terms of codebase and team size
    - Issues detectable as early as possible

    #### Disclaimer:

    This is not supposed to be a template, boilerplate or a framework. It is an opinionated guide
  that shows how to do some things in a certain way. You are not forced to do everything exactly as
  it is shown here, decide what works best for you and your team and stay consistent with your
  style.

    To get most out of it, do not get limited by the technologies used in this sample app, but
  rather focus on the principles and the concepts that are being presented here. The tools and
  libraries used here are just a suggestion, you can always replace them with something that fits
  your needs better. Sometimes, your project might require a slightly different approach, and that's
  totally fine.

    ## Table Of Contents:

    - [💻 Application Overview](docs/application-overview.md)
    - [⚙️ Project Standards](docs/project-standards.md)
    - [🗄️ Project Structure](docs/project-structure.md)
    - [🧱 Components And Styling](docs/components-and-styling.md)
    - [📡 API Layer](docs/api-layer.md)
    - [🗃️ State Management](docs/state-management.md)
    - [🧪 Testing](docs/testing.md)
    - [⚠️ Error Handling](docs/error-handling.md)
    - [🔐 Security](docs/security.md)
    - [🚄 Performance](docs/performance.md)
    - [🌐 Deployment](docs/deployment.md)
    - [📚 Additional Resources](docs/additional-resources.md)

    ## Contributing

    Contributions are always welcome! If you have any ideas, suggestions, fixes, feel free to
  contribute. You can do that by going through the following steps:

    1. Clone this repo
    2. Create a branch: `git checkout -b your-feature`
    3. Execute the `yarn prepare` script.
    4. Make some changes
    5. Test your changes
    6. Push your branch and open a Pull Request

    ## License

    [MIT](/LICENSE)
</file>

</files>